"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class Rectangle{constructor(t=0,i=0,h=0,e=0,s=!1){this.width=t,this.height=i,this.x=h,this.y=e,this.rot=s,this.oversized=!1,this.data={}}static Collide(t,i){return t.collide(i)}static Contain(t,i){return t.contain(i)}area(){return this.width*this.height}collide(t){return t.x<this.x+this.width&&t.x+t.width>this.x&&t.y<this.y+this.height&&t.y+t.height>this.y}contain(t){return t.x>=this.x&&t.y>=this.y&&t.x+t.width<=this.x+this.width&&t.y+t.height<=this.y+this.height}}class Bin{}class MaxRectsBin extends Bin{constructor(t=EDGE_MAX_VALUE,i=EDGE_MAX_VALUE,h=0,e={smart:!0,pot:!0,square:!0,allowRotation:!1}){super(),this.maxWidth=t,this.maxHeight=i,this.padding=h,this.options=e,this.freeRects=[],this.rects=[],this.verticalExpand=!1,this.width=this.options.smart?0:t,this.height=this.options.smart?0:i,this.freeRects.push(new Rectangle(this.maxWidth+this.padding,this.maxHeight+this.padding)),this.stage=new Rectangle(this.width,this.height)}add(...t){let i,h,e,s;if(1===t.length){if("object"!=typeof t[0])throw new Error("MacrectsBin.add(): Wrong parameters");i=(s=t[0]).width,h=s.height}else i=t[0],h=t[1],e=t.length>2?t[2]:null;let n=this.findNode(i+this.padding,h+this.padding);if(n){this.updateBinSize(n);let t=this.freeRects.length,d=0;for(;d<t;)this.splitNode(this.freeRects[d],n)&&(this.freeRects.splice(d,1),t--,d--),d++;return this.pruneFreeList(),this.verticalExpand=this.width>this.height,s?(s.x=n.x,s.y=n.y,s.rot=n.rot):(s=new Rectangle(i,h,n.x,n.y,n.rot)).data=e,this.rects.push(s),s}if(this.verticalExpand){if(this.updateBinSize(new Rectangle(i+this.padding,h+this.padding,0,this.height+this.padding))||this.updateBinSize(new Rectangle(i+this.padding,h+this.padding,this.width+this.padding,0)))return s?this.add(s):this.add(i,h,e)}else if(this.updateBinSize(new Rectangle(i+this.padding,h+this.padding,this.width+this.padding,0))||this.updateBinSize(new Rectangle(i+this.padding,h+this.padding,0,this.height+this.padding)))return s?this.add(s):this.add(i,h,e)}findNode(t,i){let h,e,s,n=Number.MAX_VALUE;for(let d in this.freeRects)(e=this.freeRects[d]).width>=t&&e.height>=i&&(h=e.width*e.height-t*i)<n&&(s=new Rectangle(t,i,e.x,e.y),n=h),this.options.allowRotation&&e.width>=i&&e.height>=t&&(h=e.width*e.height-i*t)<n&&(s=new Rectangle(i,t,e.x,e.y,!0),n=h);return s}splitNode(t,i){if(!t.collide(i))return!1;if(i.x<t.x+t.width&&i.x+i.width>t.x){if(i.y>t.y&&i.y<t.y+t.height){let h=new Rectangle(t.width,i.y-t.y,t.x,t.y);this.freeRects.push(h)}if(i.y+i.height<t.y+t.height){let h=new Rectangle(t.width,t.y+t.height-(i.y+i.height),t.x,i.y+i.height);this.freeRects.push(h)}}if(i.y<t.y+t.height&&i.y+i.height>t.y){if(i.x>t.x&&i.x<t.x+t.width){let h=new Rectangle(i.x-t.x,t.height,t.x,t.y);this.freeRects.push(h)}if(i.x+i.width<t.x+t.width){let h=new Rectangle(t.x+t.width-(i.x+i.width),t.height,i.x+i.width,t.y);this.freeRects.push(h)}}return!0}pruneFreeList(){let t=0,i=0,h=this.freeRects.length;for(;t<h;){i=t+1;let e=this.freeRects[t];for(;i<h;){let s=this.freeRects[i];if(s.contain(e)){this.freeRects.splice(t,1),t--,h--;break}e.contain(s)&&(this.freeRects.splice(i,1),i--,h--),i++}t++}}updateBinSize(t){if(!this.options.smart)return!1;if(this.stage.contain(t))return!1;let i=Math.max(this.width,t.x+t.width-this.padding),h=Math.max(this.height,t.y+t.height-this.padding);return this.options.pot&&(i=Math.pow(2,Math.ceil(Math.log(i)*Math.LOG2E)),h=Math.pow(2,Math.ceil(Math.log(h)*Math.LOG2E))),this.options.square&&(i=h=Math.max(i,h)),!(i>this.maxWidth+this.padding||h>this.maxHeight+this.padding)&&(this.expandFreeRects(i+this.padding,h+this.padding),this.width=this.stage.width=i,this.height=this.stage.height=h,!0)}expandFreeRects(t,i){this.freeRects.forEach((h,e)=>{h.x+h.width>=Math.min(this.width+this.padding,t)&&(h.width=t-h.x);h.y+h.height>=Math.min(this.height+this.padding,i)&&(h.height=i-h.y)},this),this.freeRects.push(new Rectangle(t-this.width-this.padding,i,this.width+this.padding,0)),this.freeRects.push(new Rectangle(t,i-this.height-this.padding,0,this.height+this.padding)),this.freeRects.forEach((t,i)=>{(t.width<=0||t.height<=0)&&this.freeRects.splice(i,1)},this),this.pruneFreeList()}}class OversizedElementBin extends Bin{constructor(...t){if(super(),this.rects=[],1===t.length){if("object"!=typeof t[0])throw new Error("OversizedElementBin: Wrong parameters");const i=t[0];this.rects=[i],this.width=i.width,this.height=i.height,this.data=i.data,i.oversized=!0}else{this.width=t[0],this.height=t[1],this.data=t.length>2?t[2]:null;const i=new Rectangle(this.width,this.height);i.oversized=!0,i.data=this.data,this.rects.push(i)}this.freeRects=[],this.maxWidth=this.width,this.maxHeight=this.height,this.options={smart:!1,pot:!1,square:!1}}add(){}}const EDGE_MAX_VALUE=4096;class MaxRectsPacker{constructor(t=EDGE_MAX_VALUE,i=EDGE_MAX_VALUE,h=0,e={smart:!0,pot:!0,square:!0,allowRotation:!1}){this.width=t,this.height=i,this.padding=h,this.options=e,this.bins=[]}add(...t){let i,h,e;if(1===t.length){if("object"!=typeof t[0])throw new Error("MacrectsPacker.add(): Wrong parameters");const i=t[0];if(i.width>this.width||i.height>this.height)this.bins.push(new OversizedElementBin(i));else{let t=this.bins.find(t=>void 0!==t.add(i));if(!t){let t=new MaxRectsBin(this.width,this.height,this.padding,this.options);t.add(i),this.bins.push(t)}}}else if(i=t[0],h=t[1],e=t.length>2?t[2]:null,i>this.width||h>this.height)this.bins.push(new OversizedElementBin(i,h,e));else{let t=this.bins.find(t=>void 0!==t.add(i,h,e));if(!t){let t=new MaxRectsBin(this.width,this.height,this.padding,this.options);t.add(i,h,e),this.bins.push(t)}}}addArray(t){this.sort(t).forEach(t=>this.add(t))}load(t){t.forEach((t,i)=>{if(t.maxWidth>this.width||t.maxHeight>this.height)this.bins.push(new OversizedElementBin(t.width,t.height,{}));else{let h=new MaxRectsBin(this.width,this.height,this.padding,t.options);h.freeRects.splice(0),t.freeRects.forEach((t,i)=>{h.freeRects.push(new Rectangle(t.width,t.height,t.x,t.y))}),h.width=t.width,h.height=t.height,this.bins[i]=h}},this)}save(){let t=[];return this.bins.forEach(i=>{let h={width:i.width,height:i.height,maxWidth:i.maxWidth,maxHeight:i.maxHeight,freeRects:[],rects:[],options:i.options};i.freeRects.forEach(t=>{h.freeRects.push({x:t.x,y:t.y,width:t.width,height:t.height})});t.push(h)}),t}sort(t){return t.slice().sort((t,i)=>Math.max(i.width,i.height)-Math.max(t.width,t.height))}}exports.Bin=Bin,exports.MaxRectsBin=MaxRectsBin,exports.MaxRectsPacker=MaxRectsPacker,exports.OversizedElementBin=OversizedElementBin,exports.Rectangle=Rectangle;
